{Threats to validity includes threats to internal, external, and construct validity. To minimize threats to internal validity, we have made sure that our implementations are correct. For baseline, Wang et al.~\cite{wang2016automatically} are unable to share their source code since their approach is under US patent application. Thus, we reimplement their approach by following the description in their paper and querying with the first author\footnote{We provide the source code of our implementation at \url{https://drive.google.com/open?id=0B3FfOb7cKbK3UWlRMEhUX3FJU2s}}. Regarding threats to external validity, our dataset consists only of four open source Java projects. However, the projects has varying statistics in average buggy rates and number of source code files. In the future, we will minimize threats to external validity further by experimenting on more projects with more varying statistics and also projects that are closed source and written in different programming languages (i.e., C++, Python, etc.). To minimize threats to construct validity, we use of evaluation metrics that are common in defect prediction~\cite{menzies2007data, menzies2010defect, nam2013transfer}.
}
%The projects for this paper contain a large variance in average buggy rates and program elements. Typically, we choose the projects which have more than 200 program elements and more than 10 bugs for running the experiments. However, there is a chance that our projects are not generalizable enough to represent all software projects. Thus, the proposed approach might get better or worse results for the other projects. Furthermore, the proposed semi-supervised autoencoder is only evaluated on open source Java projects. In the future work, we would like to employ the proposed approach on close source software and projects written in different languages (i.e., C++, Python, etc.).

%The examined projects in this work have a large variance in average buggy rates. We have tried our best to make our dataset general and representative. However, it is still possible that these ten projects are not generalizable enough to represent all software projects. Given projects that are not included in the ten projects, our proposed approach might generate better or worse results. Our proposed semantic features generation approach is only evaluated on open source
%Java projects. Its performance on closed source software and
%projects written in other languages is unknown.